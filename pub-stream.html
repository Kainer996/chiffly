<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pub Stream - Chiffly</title>
    <link rel="stylesheet" href="main-home-styles.css?v=5">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            background: #1a1a1a;
            color: white;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
        }

        .stream-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 1rem;
            padding: 1rem;
        }

        .stream-header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .pub-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .pub-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .pub-details h2 {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
        }

        .pub-details p {
            margin: 0;
            opacity: 0.7;
            font-size: 0.9rem;
        }

        .stream-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .theme-selector {
            display: flex;
            gap: 0.5rem;
            margin-right: 1rem;
            padding-right: 1rem;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .theme-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .theme-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .theme-btn.active {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            border-color: #ed8936;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-btn.active {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
        }

        .control-btn.danger {
            background: linear-gradient(135deg, #e53e3e, #c53030);
        }

        .main-video-area {
            background: #2d3748;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .host-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: linear-gradient(135deg, #2d3748, #1a202c);
        }

        .video-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #2d3748, #1a202c);
            color: white;
        }

        .video-placeholder i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .video-placeholder h3 {
            margin: 0 0 0.5rem 0;
            font-family: 'Poppins', sans-serif;
        }

        .video-placeholder p {
            margin: 0;
            opacity: 0.7;
            text-align: center;
        }

        .live-indicator {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: #e53e3e;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            display: none;
            align-items: center;
            gap: 0.5rem;
        }

        .live-indicator.active {
            display: flex;
        }

        .live-dot {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .chat-area {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .chat-header h3 {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            font-size: 1.1rem;
        }

        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            max-height: calc(100vh - 300px);
        }

        .chat-message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #ed8936;
        }

        .message-author {
            font-weight: 600;
            color: #ed8936;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .message-text {
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .message-time {
            font-size: 0.8rem;
            opacity: 0.5;
            margin-top: 0.25rem;
        }

        .chat-input-area {
            padding: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-input-container {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .chat-send-btn {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            border: none;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
        }

        .participants-area {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
        }

        .participants-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .participants-header h3 {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            font-size: 1.1rem;
        }

        .participants-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
        }

        .participant-slot {
            aspect-ratio: 16/9;
            background: #2d3748;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .participant-slot:hover {
            border-color: #ed8936;
        }

        .participant-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .participant-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #2d3748, #1a202c);
            color: rgba(255, 255, 255, 0.5);
        }

        .participant-placeholder i {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .participant-placeholder span {
            font-size: 0.8rem;
        }

        .participant-name {
            position: absolute;
            bottom: 0.5rem;
            left: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            text-align: center;
            font-weight: 500;
        }

        .leave-slot-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .leave-slot-btn:hover {
            background: rgba(220, 53, 69, 1);
            transform: scale(1.1);
        }

        .participant-slot:not(.participant-slot:has(.participant-placeholder)):hover .participant-name {
            opacity: 0.7;
        }

        /* Enhanced hover effects for clickable slots */
        .participant-slot .participant-placeholder {
            transition: all 0.3s ease;
        }

        .participant-slot:hover .participant-placeholder {
            background: linear-gradient(135deg, #3d4852, #2d3748);
            transform: scale(1.02);
        }

        .clickable-slot .participant-placeholder {
            border: 2px dashed rgba(237, 137, 54, 0.3);
        }

        .clickable-slot:hover .participant-placeholder {
            border-color: rgba(237, 137, 54, 0.6);
            background: linear-gradient(135deg, rgba(237, 137, 54, 0.1), rgba(221, 107, 32, 0.1));
        }

        .connecting-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 8px;
            z-index: 5;
        }

        .connecting-indicator i {
            font-size: 1.5rem;
            color: #ed8936;
        }

        .connecting-indicator span {
            font-size: 0.8rem;
        }

        .back-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 1024px) {
            .stream-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
            }

            .chat-area {
                order: 3;
                max-height: 300px;
            }

            .participants-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .stream-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
                gap: 0.5rem;
                padding: 0.5rem;
            }

            .stream-header {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .stream-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
                justify-content: center;
            }

            .control-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
                min-width: 80px;
            }

            .control-btn span {
                display: none;
            }

            .control-btn i {
                margin: 0;
            }

            .theme-selector {
                order: -1;
                width: 100%;
                justify-content: center;
                margin: 0;
                padding: 0;
                border: none;
            }

            .theme-btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.7rem;
            }

            .chat-area {
                order: 3;
            }

            .participants-area {
                order: 4;
            }

            /* Show camera switch button on mobile when camera is on */
            #switchCameraBtn {
                background: rgba(255, 255, 255, 0.15);
                border-color: rgba(255, 255, 255, 0.3);
            }

            #switchCameraBtn:hover {
                background: rgba(255, 255, 255, 0.25);
            }
        }

        @media (max-width: 480px) {
            .stream-container {
                padding: 0.25rem;
                gap: 0.25rem;
            }

            .stream-header {
                padding: 0.75rem;
            }

            .pub-details h2 {
                font-size: 1.2rem;
            }

            .pub-details p {
                font-size: 0.8rem;
            }

            .control-btn {
                padding: 0.4rem 0.6rem;
                min-width: 60px;
            }

            .theme-btn {
                padding: 0.3rem 0.5rem;
                font-size: 0.65rem;
            }
        }

        /* Cyberpunk Theme */
        body.cyberpunk {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0033 50%, #000a1a 100%);
        }

        body.cyberpunk .stream-header {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        body.cyberpunk .pub-icon {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
        }

        body.cyberpunk .control-btn.active {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
        }

        body.cyberpunk .theme-btn.active {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
        }

        body.cyberpunk .main-video-area {
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        }

        body.cyberpunk .video-placeholder {
            background: linear-gradient(135deg, #001122, #002244);
        }

        body.cyberpunk .chat-area {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        body.cyberpunk .chat-message {
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid #00ffff;
        }

        body.cyberpunk .message-author {
            color: #00ffff;
        }

        body.cyberpunk .chat-send-btn {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
        }

        body.cyberpunk .participants-area {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        body.cyberpunk .participant-slot {
            border: 2px solid rgba(0, 255, 255, 0.2);
        }

        body.cyberpunk .participant-slot:hover {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        body.cyberpunk .participant-placeholder {
            background: linear-gradient(135deg, #001122, #002244);
        }

        /* Medieval Theme */
        body.medieval {
            background: linear-gradient(135deg, #2d1810 0%, #4a2c17 50%, #1a0f08 100%);
        }

        body.medieval .stream-header {
            background: rgba(139, 69, 19, 0.3);
            border: 1px solid rgba(218, 165, 32, 0.5);
            box-shadow: 0 0 20px rgba(218, 165, 32, 0.2);
        }

        body.medieval .pub-icon {
            background: linear-gradient(135deg, #daa520, #b8860b);
        }

        body.medieval .control-btn.active {
            background: linear-gradient(135deg, #daa520, #b8860b);
        }

        body.medieval .theme-btn.active {
            background: linear-gradient(135deg, #daa520, #b8860b);
        }

        body.medieval .main-video-area {
            border: 2px solid rgba(218, 165, 32, 0.4);
            box-shadow: 0 0 30px rgba(218, 165, 32, 0.2);
        }

        body.medieval .video-placeholder {
            background: linear-gradient(135deg, #3d2817, #2d1810);
        }

        body.medieval .chat-area {
            background: rgba(139, 69, 19, 0.2);
            border: 1px solid rgba(218, 165, 32, 0.3);
        }

        body.medieval .chat-message {
            background: rgba(139, 69, 19, 0.3);
            border-left: 3px solid #daa520;
        }

        body.medieval .message-author {
            color: #daa520;
        }

        body.medieval .chat-send-btn {
            background: linear-gradient(135deg, #daa520, #b8860b);
        }

        body.medieval .participants-area {
            background: rgba(139, 69, 19, 0.2);
            border: 1px solid rgba(218, 165, 32, 0.3);
        }

        body.medieval .participant-slot {
            border: 2px solid rgba(218, 165, 32, 0.3);
        }

        body.medieval .participant-slot:hover {
            border-color: #daa520;
            box-shadow: 0 0 15px rgba(218, 165, 32, 0.3);
        }

        body.medieval .participant-placeholder {
            background: linear-gradient(135deg, #3d2817, #2d1810);
        }

        /* Beach Bar Theme */
        body.beach {
            background: linear-gradient(135deg, #87ceeb 0%, #20b2aa 30%, #f0e68c 70%, #daa520 100%);
        }

        body.beach .stream-header {
            background: rgba(32, 178, 170, 0.3);
            border: 1px solid rgba(135, 206, 235, 0.5);
            box-shadow: 0 0 20px rgba(135, 206, 235, 0.3);
        }

        body.beach .pub-icon {
            background: linear-gradient(135deg, #20b2aa, #87ceeb);
        }

        body.beach .control-btn.active {
            background: linear-gradient(135deg, #20b2aa, #87ceeb);
        }

        body.beach .theme-btn.active {
            background: linear-gradient(135deg, #20b2aa, #87ceeb);
        }

        body.beach .main-video-area {
            border: 2px solid rgba(135, 206, 235, 0.5);
            box-shadow: 0 0 30px rgba(135, 206, 235, 0.3);
        }

        body.beach .video-placeholder {
            background: linear-gradient(135deg, #4682b4, #20b2aa);
        }

        body.beach .chat-area {
            background: rgba(135, 206, 235, 0.2);
            border: 1px solid rgba(32, 178, 170, 0.4);
        }

        body.beach .chat-message {
            background: rgba(135, 206, 235, 0.3);
            border-left: 3px solid #20b2aa;
        }

        body.beach .message-author {
            color: #20b2aa;
        }

        body.beach .chat-send-btn {
            background: linear-gradient(135deg, #20b2aa, #87ceeb);
        }

        body.beach .participants-area {
            background: rgba(135, 206, 235, 0.2);
            border: 1px solid rgba(32, 178, 170, 0.4);
        }

        body.beach .participant-slot {
            border: 2px solid rgba(135, 206, 235, 0.4);
        }

        body.beach .participant-slot:hover {
            border-color: #20b2aa;
            box-shadow: 0 0 15px rgba(32, 178, 170, 0.4);
        }

        body.beach .participant-placeholder {
            background: linear-gradient(135deg, #4682b4, #20b2aa);
        }

        /* Beach theme decorative elements */
        body.beach::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><defs><radialGradient id="sun" cx="80%" cy="20%"><stop offset="0%" stop-color="%23ffd700" stop-opacity="0.3"/><stop offset="100%" stop-color="%23ffd700" stop-opacity="0"/></radialGradient></defs><circle cx="800" cy="200" r="100" fill="url(%23sun)"/></svg>');
            pointer-events: none;
            z-index: -1;
        }

        /* Cyberpunk decorative elements */
        body.cyberpunk::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><defs><linearGradient id="neon" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="%2300ffff" stop-opacity="0.1"/><stop offset="50%" stop-color="%23ff00ff" stop-opacity="0.1"/><stop offset="100%" stop-color="%2300ffff" stop-opacity="0.1"/></linearGradient></defs><rect x="0" y="0" width="100" height="1000" fill="url(%23neon)"/><rect x="200" y="0" width="50" height="1000" fill="url(%23neon)"/><rect x="400" y="0" width="75" height="1000" fill="url(%23neon)"/></svg>');
            pointer-events: none;
            z-index: -1;
            animation: cyberpunkGlow 3s ease-in-out infinite alternate;
        }

        /* Medieval decorative elements */
        body.medieval::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><defs><radialGradient id="torch" cx="50%" cy="50%"><stop offset="0%" stop-color="%23daa520" stop-opacity="0.2"/><stop offset="100%" stop-color="%23daa520" stop-opacity="0"/></radialGradient></defs><circle cx="100" cy="100" r="80" fill="url(%23torch)"/><circle cx="900" cy="200" r="60" fill="url(%23torch)"/><circle cx="200" cy="800" r="70" fill="url(%23torch)"/></svg>');
            pointer-events: none;
            z-index: -1;
            animation: torchFlicker 2s ease-in-out infinite alternate;
        }

        @keyframes cyberpunkGlow {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes torchFlicker {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Back Button -->
    <button class="back-btn" onclick="window.location.href='pub.html'">
        <i class="fas fa-arrow-left"></i>
    </button>

    <div class="stream-container">
        <!-- Header -->
        <div class="stream-header">
            <div class="pub-info">
                <div class="pub-icon">
                    <i class="fas fa-wine-glass"></i>
                </div>
                <div class="pub-details">
                    <h2 id="pubName">My Cozy Pub</h2>
                    <p id="pubDescription">Welcome to our virtual pub! Grab a drink and chat.</p>
                </div>
            </div>
            <div class="stream-controls">
                <div class="theme-selector">
                    <button class="theme-btn active" onclick="setTheme('default')">Default</button>
                    <button class="theme-btn" onclick="setTheme('cyberpunk')">Cyberpunk</button>
                    <button class="theme-btn" onclick="setTheme('medieval')">Medieval</button>
                    <button class="theme-btn" onclick="setTheme('beach')">Beach Bar</button>
                </div>
                <button class="control-btn" id="micBtn" onclick="toggleMic()">
                    <i class="fas fa-microphone"></i>
                    <span>Mic</span>
                </button>
                <button class="control-btn" id="cameraBtn" onclick="toggleCamera()">
                    <i class="fas fa-video"></i>
                    <span>Camera</span>
                </button>
                <button class="control-btn" id="switchCameraBtn" onclick="switchCamera()" style="display: none;">
                    <i class="fas fa-sync-alt"></i>
                    <span>Back Cam</span>
                </button>
                <button class="control-btn" id="startStreamBtn" onclick="startStream()">
                    <i class="fas fa-broadcast-tower"></i>
                    <span>Start Stream</span>
                </button>
                <button class="control-btn danger" onclick="leavePub()">
                    <i class="fas fa-sign-out-alt"></i>
                    <span>Leave</span>
                </button>
            </div>
        </div>

        <!-- Main Video Area -->
        <div class="main-video-area">
            <video id="hostVideo" class="host-video" autoplay muted playsinline style="display: none;"></video>
            <div class="video-placeholder" id="videoPlaceholder">
                <i class="fas fa-video-slash"></i>
                <h3>Camera Off</h3>
                <p>Click "Camera" to start your video stream</p>
            </div>
            <div class="live-indicator" id="liveIndicator">
                <div class="live-dot"></div>
                LIVE
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat-area">
            <div class="chat-header">
                <i class="fas fa-comments"></i>
                <h3>Pub Chat</h3>
                <span id="userCount">(1 person)</span>
            </div>
            <div class="chat-messages" id="chatMessages">
                <div class="chat-message">
                    <div class="message-author">System</div>
                    <div class="message-text">Welcome to the pub! Start chatting with other patrons.</div>
                    <div class="message-time">Just now</div>
                </div>
            </div>
            <div class="chat-input-area">
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Type your message..." maxlength="500">
                    <button class="chat-send-btn" onclick="sendMessage()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Participants Area -->
        <div class="participants-area">
            <div class="participants-header">
                <i class="fas fa-users"></i>
                <h3>Participants</h3>
                <span id="participantCount">(0/6 slots)</span>
            </div>
            <div class="participants-grid">
                <div class="participant-slot" id="participant1">
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                </div>
                <div class="participant-slot" id="participant2">
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                </div>
                <div class="participant-slot" id="participant3">
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                </div>
                <div class="participant-slot" id="participant4">
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                </div>
                <div class="participant-slot" id="participant5">
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                </div>
                <div class="participant-slot" id="participant6">
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        let localStream = null;
        let isStreaming = false;
        let isMicOn = false;
        let isCameraOn = false;
        let currentTheme = 'default';
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let socket = null;
        let currentRoom = null;
        let currentUser = null;
        let isHost = false;
        let streamerId = null; // ID of the host/streamer
        let peerConnections = new Map();
        let remoteStreams = new Map();
        let allParticipants = new Set(); // Track all users in the room

        // Initialize the pub stream
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved theme
            const savedTheme = localStorage.getItem('pubTheme') || 'default';
            setTheme(savedTheme, true);
            
            // Initialize socket connection and room joining
            initializeSocketConnection();
            
            // Initialize stream
            initializePubStream();
            
            // Mobile device detection and setup
            if (/Mobi|Android/i.test(navigator.userAgent)) {
                console.log('Mobile device detected');
                
                // Add mobile-specific instructions
                setTimeout(() => {
                    addChatMessage('System', 'Mobile detected! Use the camera switch button to toggle between front/back cameras when your camera is on.', true);
                }, 3000);
                
                // Add mobile tips button
                setTimeout(() => {
                    addMobileTipsButton();
                }, 5000);
                
                // Ensure video element has proper mobile attributes
                const hostVideo = document.getElementById('hostVideo');
                hostVideo.setAttribute('playsinline', 'true');
                hostVideo.setAttribute('webkit-playsinline', 'true');
            }
            
            // Periodic check to ensure all necessary peer connections exist
            setInterval(() => {
                if (socket && socket.connected) {
                    ensureAllPeerConnections();
                    // Log connection status for debugging
                    logConnectionStatus();
                }
            }, 5000); // Check every 5 seconds
        });

        function initializeTheme() {
            // Set default theme or load saved theme
            const savedTheme = localStorage.getItem('pubTheme') || 'default';
            setTheme(savedTheme, true); // true = silent initialization
        }

        function initializeSocketConnection() {
            // Get URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room');
            const username = urlParams.get('username');
            isHost = urlParams.get('host') === '1';

            if (!roomId || !username) {
                showError('Missing room or username parameters. Redirecting...');
                setTimeout(() => {
                    window.location.href = 'pub.html';
                }, 3000);
                return;
            }

            currentRoom = roomId;
            currentUser = username;

            // Initialize socket connection  
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const socketUrl = isLocalhost ? 'http://localhost:3000' : window.location.origin;
            
            console.log('Connecting to socket at:', socketUrl);
            socket = io(socketUrl, {
                transports: ['websocket', 'polling'],
                timeout: 5000,
                forceNew: true
            });

            socket.on('connect', () => {
                console.log('âœ… Connected to pub server successfully!');
                console.log('Socket ID:', socket.id);
                addChatMessage('System', 'Connected to pub server!', true);
                
                // Join the room
                console.log('Joining room:', currentRoom, 'as', currentUser, isHost ? '(host)' : '(guest)');
                socket.emit('join-room', {
                    roomId: currentRoom,
                    username: currentUser,
                    isStreamer: isHost,
                    roomType: 'pub'
                });
            });

            socket.on('disconnect', () => {
                console.log('âŒ Disconnected from pub server');
                addChatMessage('System', 'Disconnected from server. Trying to reconnect...', true);
            });

            socket.on('connect_error', (error) => {
                console.error('âŒ Socket connection error:', error);
                console.error('Error type:', error.type);
                console.error('Error description:', error.description);
                addChatMessage('System', `Connection error: ${error.message}`, true);
            });

            socket.on('error', (error) => {
                console.error('âŒ Socket error:', error);
                addChatMessage('System', `Socket error: ${error.message}`, true);
            });

            socket.on('room-state', (data) => {
                const { streamer, participants, messages } = data;
                streamerId = streamer ? streamer.id : null; // Store streamer's socket ID
                
                // Track all participants
                allParticipants.clear();
                if (streamer) allParticipants.add(streamer.id);
                participants.forEach(p => allParticipants.add(p.id));
                
                // Update participant count
                const totalParticipants = participants.length + (streamer ? 1 : 0);
                document.getElementById('participantCount').textContent = `${totalParticipants} patron${totalParticipants !== 1 ? 's' : ''}`;
                
                // Display existing messages
                messages.forEach(message => {
                    displayChatMessage(message);
                });

                // Setup WebRTC connections but DON'T auto-assign to slots
                if (isHost && participants.length > 0) {
                    // Host: create connections to all participants (they'll manually choose slots)
                    participants.forEach(participant => {
                        if (participant.id !== socket.id) {
                            createPeerConnection(participant.id);
                        }
                    });
                    // Add tracks if we have them and camera/mic are on
                    setTimeout(() => {
                        updatePeerConnections();
                    }, 200);
                } else if (!isHost && streamer) {
                    // Participant: create connection to host to see their main video
                    if (streamer.id !== socket.id) {
                        createPeerConnection(streamer.id);
                        // Add tracks if we have them and camera/mic are on
                        setTimeout(() => {
                            updatePeerConnections();
                        }, 200);
                    }
                }

                // Show welcome message
                showWelcomeMessage();
                
                // Setup participant slot click handlers for guests
                setupParticipantSlotHandlers();
                
                // Start connection health monitoring
                startConnectionHealthCheck();
            });

            socket.on('user-joined', (data) => {
                const { userId, username, isStreamer } = data;
                addChatMessage('System', `${username} ${isStreamer ? 'started hosting' : 'joined'} the table!`, true);
                updateParticipantCount();

                // Track new participant
                allParticipants.add(userId);
                if (isStreamer) streamerId = userId;

                // Create WebRTC connection for new user and add any existing tracks
                if (userId !== socket.id) {
                    createPeerConnection(userId);
                    // Add tracks if we have them and camera/mic are on
                    setTimeout(() => {
                        updatePeerConnections();
                    }, 100);
                }
            });

            socket.on('user-left', (data) => {
                const { userId, username } = data;
                addChatMessage('System', `${username} left the table.`, true);
                updateParticipantCount();

                // Remove from participant tracking
                allParticipants.delete(userId);
                if (streamerId === userId) streamerId = null;

                // Clean up WebRTC connection
                if (peerConnections.has(userId)) {
                    console.log('ðŸ§¹ Cleaning up peer connection for user:', userId);
                    peerConnections.get(userId).close();
                    peerConnections.delete(userId);
                }
                if (remoteStreams.has(userId)) {
                    console.log('ðŸ§¹ Cleaning up remote stream for user:', userId);
                    remoteStreams.delete(userId);
                }
                
                // Clean up any slots occupied by this user
                const userSlots = document.querySelectorAll(`[data-occupied-by="${userId}"]`);
                userSlots.forEach(slot => {
                    slot.innerHTML = `
                        <div class="participant-placeholder">
                            <i class="fas fa-user-plus"></i>
                            <span>Empty Slot</span>
                        </div>
                    `;
                    slot.removeAttribute('data-occupied-by');
                    console.log('ðŸ§¹ Cleaned up slot for user:', userId);
                });
            });

            socket.on('chat-message', (message) => {
                displayChatMessage(message);
            });

            // WebRTC signaling
            socket.on('offer', (data) => {
                handleOffer(data);
            });

            socket.on('answer', (data) => {
                handleAnswer(data);
            });

            socket.on('ice-candidate', (data) => {
                handleIceCandidate(data);
            });

            // Handle slot join/leave events
            socket.on('user-joined-slot', (data) => {
                handleUserJoinedSlot(data);
            });

            socket.on('user-left-slot', (data) => {
                handleUserLeftSlot(data);
            });
            
            socket.on('slot-join-confirmed', (data) => {
                handleSlotJoinConfirmed(data);
            });
        }

        function updateParticipantCount() {
            // This would be updated by the server in a real implementation
            // For now, we'll just increment/decrement as needed
        }

        function displayChatMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            
            const time = new Date(message.timestamp || Date.now()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="message-author" style="${message.isStreamer ? 'color: #f39c12;' : ''}">${message.username}</div>
                <div class="message-text">${message.text}</div>
                <div class="message-time">${time}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function setTheme(theme, silent = false) {
            // Remove all theme classes
            document.body.classList.remove('cyberpunk', 'medieval', 'beach');
            
            // Remove active class from all theme buttons
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Apply new theme
            if (theme !== 'default') {
                document.body.classList.add(theme);
            }
            
            // Set active button
            const activeBtn = Array.from(document.querySelectorAll('.theme-btn')).find(btn => 
                btn.textContent.toLowerCase().includes(theme) || 
                (theme === 'default' && btn.textContent === 'Default')
            );
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            // Update pub name and description based on theme
            const pubName = document.getElementById('pubName');
            const pubDescription = document.getElementById('pubDescription');
            
            const themeData = {
                'default': {
                    name: 'My Cozy Pub',
                    description: 'Welcome to our virtual pub! Grab a drink and chat.',
                    displayName: 'Default'
                },
                'cyberpunk': {
                    name: 'Neon Nexus Bar',
                    description: 'Welcome to the future! Jack in and connect with fellow netrunners.',
                    displayName: 'Cyberpunk'
                },
                'medieval': {
                    name: 'The Dragon\'s Tavern',
                    description: 'Gather \'round the hearth, brave adventurers! Share tales of your quests.',
                    displayName: 'Medieval'
                },
                'beach': {
                    name: 'Paradise Tiki Bar',
                    description: 'Aloha! Relax with tropical drinks and ocean vibes. ðŸŒºðŸ–ï¸',
                    displayName: 'Beach Bar'
                }
            };
            
            const currentThemeData = themeData[theme];
            pubName.textContent = currentThemeData.name;
            pubDescription.textContent = currentThemeData.description;
            
            currentTheme = theme;
            
            // Save theme preference
            localStorage.setItem('pubTheme', theme);
            
            // Add theme change message to chat (only if not silent initialization)
            if (!silent) {
                addChatMessage('System', `Pub theme changed to ${currentThemeData.displayName}! Welcome to ${currentThemeData.name}!`, true);
            }
            
            console.log(`Theme changed to: ${theme}`);
        }

        async function initializePubStream() {
            try {
                // Mobile-friendly camera constraints with better compatibility
                const constraints = {
                    video: {
                        width: { ideal: 640, max: 1280 },
                        height: { ideal: 480, max: 720 },
                        frameRate: { ideal: 15, max: 30 }, // Lower frameRate for mobile stability
                        facingMode: 'user' // Front camera by default on mobile
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000
                    }
                };

                console.log('Requesting media devices with mobile-friendly constraints...');
                
                // Request camera and microphone permissions
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                console.log('Media stream obtained successfully');
                console.log('Video tracks:', localStream.getVideoTracks());
                console.log('Audio tracks:', localStream.getAudioTracks());
                
                // Initially turn off camera and mic
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = false;
                    console.log('Video track settings:', track.getSettings());
                });
                localStream.getAudioTracks().forEach(track => track.enabled = false);
                
            } catch (error) {
                console.error('Error accessing media devices:', error);
                
                // Try fallback constraints for older mobile devices
                try {
                    console.log('Trying fallback constraints...');
                    const fallbackConstraints = {
                        video: {
                            facingMode: 'user',
                            width: { min: 320, ideal: 480, max: 640 },
                            height: { min: 240, ideal: 360, max: 480 },
                            frameRate: { max: 15 } // Very conservative for older devices
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    };
                    
                    localStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
                    console.log('Fallback media stream obtained successfully');
                    
                    // Initially turn off camera and mic
                    localStream.getVideoTracks().forEach(track => track.enabled = false);
                    localStream.getAudioTracks().forEach(track => track.enabled = false);
                    
                } catch (fallbackError) {
                    console.error('Fallback also failed:', fallbackError);
                    
                    // Try basic constraints as last resort
                    try {
                        console.log('Trying basic constraints...');
                        localStream = await navigator.mediaDevices.getUserMedia({
                            video: true,
                            audio: true
                        });
                        console.log('Basic media stream obtained successfully');
                        
                        // Initially turn off camera and mic
                        localStream.getVideoTracks().forEach(track => track.enabled = false);
                        localStream.getAudioTracks().forEach(track => track.enabled = false);
                        
                    } catch (basicError) {
                        console.error('All attempts failed:', basicError);
                        showError('Unable to access camera/microphone. Please check permissions and try refreshing the page.');
                        
                        // Show detailed error message for mobile users
                        if (/Mobi|Android/i.test(navigator.userAgent)) {
                            showError('Mobile tip: Make sure to allow camera access when prompted, and try using Chrome or Safari.');
                        }
                    }
                }
            }
        }

        function toggleMic() {
            const micBtn = document.getElementById('micBtn');
            const micIcon = micBtn.querySelector('i');
            
            if (localStream) {
                isMicOn = !isMicOn;
                localStream.getAudioTracks().forEach(track => track.enabled = isMicOn);
                
                // Update peer connections when mic state changes
                updatePeerConnections();
                
                if (isMicOn) {
                    micBtn.classList.add('active');
                    micIcon.className = 'fas fa-microphone';
                } else {
                    micBtn.classList.remove('active');
                    micIcon.className = 'fas fa-microphone-slash';
                }
            }
        }

        function ensureAllPeerConnections() {
            // Use comprehensive participant tracking
            const allConnectedUsers = new Set();
            
            // Add all tracked participants except myself
            allParticipants.forEach(userId => {
                if (userId !== socket.id) {
                    allConnectedUsers.add(userId);
                }
            });
            
            // Also add users from slots (in case tracking missed any)
            for (let i = 1; i <= 6; i++) {
                const slot = document.getElementById(`participant${i}`);
                const occupiedBy = slot?.getAttribute('data-occupied-by');
                if (occupiedBy && occupiedBy !== socket.id) {
                    allConnectedUsers.add(occupiedBy);
                }
            }
            
            // Create peer connections for any missing users
            allConnectedUsers.forEach(userId => {
                if (!peerConnections.has(userId)) {
                    console.log(`Creating missing peer connection for user: ${userId}`);
                    createPeerConnection(userId);
                } else {
                    // Check if existing connection is healthy
                    const pc = peerConnections.get(userId);
                    if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                        console.log(`Recreating unhealthy connection to user: ${userId} (state: ${pc.connectionState})`);
                        pc.close();
                        peerConnections.delete(userId);
                        createPeerConnection(userId);
                    }
                }
            });
        }

        async function updatePeerConnections() {
            console.log(`Updating tracks for all peers. Camera: ${isCameraOn}, Mic: ${isMicOn}`);
            if (!localStream) {
                console.warn("UpdatePeerConnections called but localStream is not ready.");
                return;
            }

            // Ensure we have peer connections to all relevant users
            ensureAllPeerConnections();

            let trackChanges = false;

            for (const [userId, pc] of peerConnections.entries()) {
                console.log(`Processing peer connection for ${userId}, state: ${pc.connectionState}, signaling: ${pc.signalingState}`);
                
                const videoTrack = localStream.getVideoTracks()[0];
                const audioTrack = localStream.getAudioTracks()[0];

                // --- Manage Video Track ---
                const videoSender = pc.getSenders().find(s => s.track && s.track.kind === "video");

                if (isCameraOn && videoTrack) {
                    if (!videoSender) {
                        console.log(`[Video] Adding track for ${userId}`);
                        try {
                            pc.addTrack(videoTrack, localStream);
                            trackChanges = true;
                        } catch (e) {
                            console.error(`Failed to add video track for ${userId}:`, e);
                        }
                    } else if (videoSender.track !== videoTrack) {
                        console.log(`[Video] Replacing track for ${userId}`);
                        try {
                            await videoSender.replaceTrack(videoTrack);
                        } catch (e) {
                            console.error(`Failed to replace video track for ${userId}:`, e);
                        }
                    }
                } else if (!isCameraOn && videoSender) {
                    console.log(`[Video] Removing track for ${userId}`);
                    try {
                        pc.removeTrack(videoSender);
                        trackChanges = true;
                    } catch (e) {
                        console.error(`Failed to remove video track for ${userId}:`, e);
                    }
                }

                // --- Manage Audio Track ---
                const audioSender = pc.getSenders().find(s => s.track && s.track.kind === "audio");

                if (isMicOn && audioTrack) {
                    if (!audioSender) {
                        console.log(`[Audio] Adding track for ${userId}`);
                        try {
                            pc.addTrack(audioTrack, localStream);
                            trackChanges = true;
                        } catch (e) {
                            console.error(`Failed to add audio track for ${userId}:`, e);
                        }
                    } else if (audioSender.track !== audioTrack) {
                        console.log(`[Audio] Replacing track for ${userId}`);
                        try {
                            await audioSender.replaceTrack(audioTrack);
                        } catch (e) {
                            console.error(`Failed to replace audio track for ${userId}:`, e);
                        }
                    }
                } else if (!isMicOn && audioSender) {
                    console.log(`[Audio] Removing track for ${userId}`);
                    try {
                        pc.removeTrack(audioSender);
                        trackChanges = true;
                    } catch (e) {
                        console.error(`Failed to remove audio track for ${userId}:`, e);
                    }
                }
            }

            console.log(`Track update complete. Changes made: ${trackChanges}`);
        }

        function logConnectionStatus() {
            console.log('=== CONNECTION STATUS ===');
            console.log(`Total participants tracked: ${allParticipants.size}`);
            console.log(`Total peer connections: ${peerConnections.size}`);
            console.log(`Total remote streams: ${remoteStreams.size}`);
            console.log(`Is Host: ${isHost}, Streamer ID: ${streamerId}`);
            console.log(`Camera On: ${isCameraOn}, Mic On: ${isMicOn}`);
            console.log(`Local Stream: ${localStream ? 'Available' : 'None'}`);
            
            if (localStream) {
                console.log(`Local Video Tracks: ${localStream.getVideoTracks().length}`);
                console.log(`Local Audio Tracks: ${localStream.getAudioTracks().length}`);
                localStream.getVideoTracks().forEach((track, i) => {
                    console.log(`  Video Track ${i}: enabled=${track.enabled}, state=${track.readyState}`);
                });
            }
            
            peerConnections.forEach((pc, userId) => {
                const hasVideo = pc.getSenders().some(s => s.track && s.track.kind === 'video');
                const hasAudio = pc.getSenders().some(s => s.track && s.track.kind === 'audio');
                const remoteStream = remoteStreams.get(userId);
                console.log(`${userId.substring(0,8)}: ${pc.connectionState}/${pc.signalingState}/${pc.iceConnectionState} - Send: V:${hasVideo} A:${hasAudio} - Receive: ${remoteStream ? 'Yes' : 'No'}`);
                
                if (remoteStream) {
                    console.log(`  Remote tracks: Video:${remoteStream.getVideoTracks().length} Audio:${remoteStream.getAudioTracks().length}`);
                }
            });
            
            console.log('=== END STATUS ===');
        }
        
        // Add a global function to help debug from browser console
        window.debugConnections = logConnectionStatus;
        
        // Add a function to force track addition for debugging
        window.forceAddTracks = function() {
            console.log('ðŸ”§ FORCE ADDING TRACKS TO ALL CONNECTIONS...');
            if (!localStream) {
                console.log('ðŸ”§ No local stream available');
                return;
            }
            
            peerConnections.forEach((pc, userId) => {
                console.log(`ðŸ”§ Force adding tracks to ${userId.substring(0,8)}`);
                try {
                    // Remove existing tracks
                    pc.getSenders().forEach(sender => {
                        if (sender.track) {
                            pc.removeTrack(sender);
                        }
                    });
                    
                    // Add fresh tracks
                    localStream.getTracks().forEach(track => {
                        console.log(`ðŸ”§ Adding ${track.kind} track (enabled: ${track.enabled})`);
                        pc.addTrack(track, localStream);
                    });
                    
                    // Force renegotiation
                    if (pc.signalingState === 'stable') {
                        pc.dispatchEvent(new Event('negotiationneeded'));
                    }
                } catch (e) {
                    console.error(`ðŸ”§ Error force adding tracks:`, e);
                }
            });
        };

        async function switchCamera() {
            if (!localStream) {
                showError('No camera stream available');
                return;
            }

            try {
                // Stop current video tracks
                localStream.getVideoTracks().forEach(track => track.stop());
                
                // Switch facing mode
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                
                console.log(`Switching to ${currentFacingMode} camera...`);
                
                // Get new video stream with switched camera
                const newVideoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 30, max: 60 }
                    }
                });
                
                // Replace video track in existing stream
                const newVideoTrack = newVideoStream.getVideoTracks()[0];
                const audioTracks = localStream.getAudioTracks();
                
                // Create new stream with new video track and existing audio
                localStream = new MediaStream([newVideoTrack, ...audioTracks]);
                
                // Update video element if camera is on
                if (isCameraOn) {
                    const hostVideo = document.getElementById('hostVideo');
                    hostVideo.srcObject = localStream;
                }
                
                // Update switch button text
                const switchBtn = document.getElementById('switchCameraBtn');
                if (switchBtn) {
                    switchBtn.innerHTML = `<i class="fas fa-sync-alt"></i><span>${currentFacingMode === 'user' ? 'Back Cam' : 'Front Cam'}</span>`;
                }
                
                console.log('Camera switched successfully');
                
            } catch (error) {
                console.error('Error switching camera:', error);
                showError('Unable to switch camera. This device may only have one camera.');
                
                // Revert facing mode if switch failed
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            }
        }

        function toggleCamera() {
            const cameraBtn = document.getElementById('cameraBtn');
            const cameraIcon = cameraBtn.querySelector('i');
            const hostVideo = document.getElementById('hostVideo');
            const videoPlaceholder = document.getElementById('videoPlaceholder');
            
            if (localStream) {
                isCameraOn = !isCameraOn;
                localStream.getVideoTracks().forEach(track => track.enabled = isCameraOn);
                
                // Update peer connections when camera state changes
                updatePeerConnections();
                
                // Force negotiation for all peer connections to ensure tracks are shared
                setTimeout(() => {
                    for (const [userId, pc] of peerConnections.entries()) {
                        if (pc.connectionState === 'connected' || pc.connectionState === 'new') {
                            console.log(`Forcing renegotiation with ${userId} after camera toggle`);
                            // Trigger negotiation by adding/removing a dummy track momentarily
                            if (pc.signalingState === 'stable') {
                                pc.dispatchEvent(new Event('negotiationneeded'));
                            }
                        }
                    }
                }, 500);
                
                if (isCameraOn) {
                    cameraBtn.classList.add('active');
                    cameraIcon.className = 'fas fa-video';
                    
                    // Show local video if user is host OR if they're in a participant slot
                    const userSlot = document.querySelector(`[data-occupied-by="${socket.id}"]`);
                    if (isHost) {
                        hostVideo.srcObject = localStream;
                        hostVideo.style.display = 'block';
                        videoPlaceholder.style.display = 'none';
                    } else if (userSlot) {
                        // User is in a participant slot, update that slot's video
                        const slotVideo = userSlot.querySelector('video');
                        if (slotVideo) {
                            slotVideo.srcObject = localStream;
                        }
                    }
                    
                    // Show camera switch button on mobile
                    const switchBtn = document.getElementById('switchCameraBtn');
                    if (switchBtn && /Mobi|Android/i.test(navigator.userAgent)) {
                        switchBtn.style.display = 'flex';
                    }
                } else {
                    cameraBtn.classList.remove('active');
                    cameraIcon.className = 'fas fa-video-slash';
                    
                    // Only hide local video if user is host
                    if (isHost) {
                        hostVideo.style.display = 'none';
                        videoPlaceholder.style.display = 'flex';
                        videoPlaceholder.innerHTML = `
                            <i class="fas fa-video-slash"></i>
                            <h3>Camera Off</h3>
                            <p>Click "Camera" to start your video stream</p>
                        `;
                    }
                    
                    // Hide camera switch button when camera is off
                    const switchBtn = document.getElementById('switchCameraBtn');
                    if (switchBtn) {
                        switchBtn.style.display = 'none';
                    }
                }
            } else {
                showError('Camera not available. Please refresh the page and allow camera access.');
            }
        }

        function startStream() {
            const startBtn = document.getElementById('startStreamBtn');
            const liveIndicator = document.getElementById('liveIndicator');
            
            if (!isStreaming) {
                isStreaming = true;
                startBtn.innerHTML = '<i class="fas fa-stop"></i><span>Stop Stream</span>';
                startBtn.classList.add('danger');
                liveIndicator.classList.add('active');
                
                // Notify server that streaming is active
                if (socket) {
                    socket.emit('chat-message', {
                        text: 'ðŸ“º Started the pub stream! ðŸ»'
                    });
                }
                
                console.log('Stream started');
            } else {
                isStreaming = false;
                startBtn.innerHTML = '<i class="fas fa-broadcast-tower"></i><span>Start Stream</span>';
                startBtn.classList.remove('danger');
                liveIndicator.classList.remove('active');
                
                // Notify server that streaming stopped
                if (socket) {
                    socket.emit('chat-message', {
                        text: 'ðŸ“º Ended the pub stream. Thanks for watching! ðŸ»'
                    });
                }
                
                console.log('Stream stopped');
            }
        }

        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message && socket && currentRoom) {
                socket.emit('chat-message', {
                    text: message
                });
                chatInput.value = '';
            }
        }

        function addChatMessage(author, text, isSystem = false) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="message-author" style="${isSystem ? 'color: #4299e1;' : ''}">${author}</div>
                <div class="message-text">${text}</div>
                <div class="message-time">${timeString}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function leavePub() {
            if (confirm('Are you sure you want to leave the pub?')) {
                // Clean up WebRTC connections
                peerConnections.forEach((peerConnection, userId) => {
                    peerConnection.close();
                });
                peerConnections.clear();
                remoteStreams.clear();
                
                // Clean up streams
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Disconnect from socket
                if (socket) {
                    socket.disconnect();
                }
                
                // Redirect back to pub list
                window.location.href = 'pub.html';
            }
        }

        function showError(message) {
            addChatMessage('System', `Error: ${message}`, true);
        }

        function showMobileCameraTips() {
            const tips = [
                "ðŸ“± Mobile Camera Tips:",
                "â€¢ Make sure to allow camera access when prompted",
                "â€¢ Try refreshing the page if camera doesn't work",
                "â€¢ Use Chrome or Safari for best compatibility",
                "â€¢ Check if another app is using your camera",
                "â€¢ Try switching between front/back cameras",
                "â€¢ Ensure you have good lighting for better quality"
            ];
            
            tips.forEach((tip, index) => {
                setTimeout(() => {
                    addChatMessage('System', tip, true);
                }, index * 1000);
            });
        }

        // Add mobile camera tips button for troubleshooting
        function addMobileTipsButton() {
            if (/Mobi|Android/i.test(navigator.userAgent)) {
                const chatMessages = document.getElementById('chatMessages');
                const tipsButton = document.createElement('div');
                tipsButton.className = 'chat-message';
                tipsButton.style.cursor = 'pointer';
                tipsButton.style.background = 'rgba(66, 153, 225, 0.2)';
                tipsButton.style.border = '1px solid #4299e1';
                tipsButton.onclick = showMobileCameraTips;
                
                tipsButton.innerHTML = `
                    <div class="message-author" style="color: #4299e1;">System</div>
                    <div class="message-text">ðŸ“± Having camera issues? Click here for mobile tips!</div>
                    <div class="message-time">Help</div>
                `;
                
                chatMessages.appendChild(tipsButton);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        // Handle Enter key in chat input
        document.getElementById('chatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Handle when other users join/leave slots
        function handleUserJoinedSlot(data) {
            const { userId, username, slotNumber } = data;
            console.log(`User ${username} joined slot ${slotNumber}`);
            
            const slot = document.getElementById(`participant${slotNumber}`);
            if (!slot) return;

            // SIMPLIFIED APPROACH: Always recreate connection for clean state
            if (peerConnections.has(userId)) {
                peerConnections.get(userId).close();
                peerConnections.delete(userId);
                remoteStreams.delete(userId);
            }

            // Create fresh peer connection 
            const pc = createPeerConnection(userId);
            
            // SIMPLE FIX: Host always sends their stream to participants
            if (isHost && localStream && isCameraOn) {
                setTimeout(async () => {
                    try {
                        // Add host's tracks directly to the connection
                        localStream.getTracks().forEach(track => {
                            pc.addTrack(track, localStream);
                        });
                        
                        // Create offer immediately
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        socket.emit('offer', { target: userId, offer: offer });
                        console.log(`Host sent offer to participant ${userId.substring(0,8)}`);
                        
                    } catch (e) {
                        console.error(`Failed to create offer for ${userId.substring(0,8)}:`, e);
                    }
                }, 500);
            }

            // Clear the slot first
            slot.innerHTML = `
                <video autoplay muted playsinline class="participant-video" style="display: none;"></video>
                <div class="participant-name">${username}</div>
                <div class="connecting-indicator">
                    <i class="fas fa-circle-notch fa-spin"></i>
                    <span>Connecting camera...</span>
                    <div class="connection-tips" style="font-size: 0.7rem; margin-top: 0.5rem; opacity: 0.7;">
                        On mobile? Make sure camera permissions are enabled.
                    </div>
                </div>
            `;
            slot.setAttribute('data-occupied-by', userId);
            
            // Find the user's video stream
            const remoteStream = remoteStreams.get(userId);
            if (remoteStream) {
                // Stream is available, show it immediately
                const video = slot.querySelector('video');
                const connectingIndicator = slot.querySelector('.connecting-indicator');
                
                video.srcObject = remoteStream;
                video.style.display = 'block';
                if (connectingIndicator) {
                    connectingIndicator.remove();
                }
                
                console.log(`Stream displayed for ${username} in slot ${slotNumber}`);
            } else {
                // Stream not yet available, will be shown when received
                console.log(`Stream not yet available for user ${userId}, showing connecting indicator`);
                
                // Set up multiple retries to check for stream with more aggressive timing
                let retryCount = 0;
                const maxRetries = 15; // Increased retries
                const retryInterval = setInterval(() => {
                    const currentSlot = document.getElementById(`participant${slotNumber}`);
                    const currentConnecting = currentSlot?.querySelector('.connecting-indicator');
                    
                    if (currentConnecting && currentSlot?.getAttribute('data-occupied-by') === userId) {
                        // Check again for the stream
                        const stream = remoteStreams.get(userId);
                        if (stream) {
                            const video = currentSlot.querySelector('video');
                            if (video) {
                                video.srcObject = stream;
                                video.style.display = 'block';
                                currentConnecting.remove();
                                clearInterval(retryInterval);
                                console.log(`Stream connected for ${username} in slot ${slotNumber} after ${retryCount + 1} attempts`);
                                return;
                            }
                        }
                        
                        // Try to reconnect if peer connection failed
                        const pc = peerConnections.get(userId);
                        if (pc && (pc.connectionState === 'failed' || pc.connectionState === 'disconnected')) {
                            console.log(`Peer connection failed for ${userId}, attempting to reconnect...`);
                            pc.close();
                            createPeerConnection(userId);
                            setTimeout(() => updatePeerConnections(), 100);
                        }
                    } else {
                        // Slot no longer exists or user changed, stop retrying
                        clearInterval(retryInterval);
                        return;
                    }
                    
                    retryCount++;
                    if (retryCount >= maxRetries) {
                        clearInterval(retryInterval);
                        console.log(`Max retries reached for ${username} in slot ${slotNumber}`);
                        
                        // Final attempt: recreate connection if still stuck
                        const currentSlot = document.getElementById(`participant${slotNumber}`);
                        if (currentSlot?.querySelector('.connecting-indicator')) {
                            console.log(`Final attempt: recreating connection for ${userId}`);
                            const pc = peerConnections.get(userId);
                            if (pc) {
                                pc.close();
                                createPeerConnection(userId);
                                setTimeout(() => updatePeerConnections(), 100);
                            }
                        }
                    }
                }, 800); // Check every 800ms for faster response
            }
        }

        function handleUserLeftSlot(data) {
            const { userId, username, slotNumber } = data;
            console.log(`User ${username} left slot ${slotNumber}`);
            
            const slot = document.getElementById(`participant${slotNumber}`);
            if (slot && slot.getAttribute('data-occupied-by') === userId) {
                // Reset slot to empty state
                slot.innerHTML = `
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                `;
                slot.removeAttribute('data-occupied-by');
            }
        }
        
        async function handleSlotJoinConfirmed(data) {
            const { slotNumber } = data;
            console.log('ðŸŽ¥ PARTICIPANT: Starting bulletproof video track transmission...');
            
            // BULLETPROOF FIX: Multiple approaches to ensure participant video reaches host
            let attempts = 0;
            const maxAttempts = 3;
            
            const sendParticipantVideo = async () => {
                attempts++;
                console.log(`ðŸŽ¥ ATTEMPT ${attempts}: Sending participant video to all connections...`);
                
                for (const [userId, pc] of peerConnections.entries()) {
                    try {
                        console.log(`ðŸŽ¥ Processing connection to ${userId.substring(0,8)}`);
                        console.log(`ðŸŽ¥ Connection state: ${pc.connectionState}, Signaling: ${pc.signalingState}`);
                        
                        if (localStream && isCameraOn) {
                            // FORCE ADD TRACKS - Replace any existing ones
                            const videoTrack = localStream.getVideoTracks()[0];
                            const audioTrack = localStream.getAudioTracks()[0];
                            
                            console.log(`ðŸŽ¥ Video track: ${videoTrack ? 'Available' : 'Missing'}, enabled: ${videoTrack?.enabled}`);
                            console.log(`ðŸŽ¥ Audio track: ${audioTrack ? 'Available' : 'Missing'}, enabled: ${audioTrack?.enabled}`);
                            
                            // Remove existing senders first
                            const senders = pc.getSenders();
                            for (const sender of senders) {
                                if (sender.track) {
                                    console.log(`ðŸŽ¥ Removing existing ${sender.track.kind} sender`);
                                    pc.removeTrack(sender);
                                }
                            }
                            
                            // Add fresh tracks
                            if (videoTrack) {
                                pc.addTrack(videoTrack, localStream);
                                console.log(`ðŸŽ¥ âœ… Added fresh video track to ${userId.substring(0,8)}`);
                            }
                            if (audioTrack) {
                                pc.addTrack(audioTrack, localStream);
                                console.log(`ðŸŽ¥ âœ… Added fresh audio track to ${userId.substring(0,8)}`);
                            }
                            
                            // FORCE RENEGOTIATION - Multiple methods
                            if (pc.signalingState === 'stable') {
                                console.log(`ðŸŽ¥ ðŸš€ CREATING RENEGOTIATION OFFER for ${userId.substring(0,8)}`);
                                
                                // Method 1: Direct offer creation
                                const offer = await pc.createOffer();
                                await pc.setLocalDescription(offer);
                                
                                console.log(`ðŸŽ¥ ðŸ“¡ SENDING OFFER - Video in SDP: ${offer.sdp.includes('m=video')}`);
                                socket.emit('offer', {
                                    target: userId,
                                    offer: offer
                                });
                                
                                // Method 2: Also trigger negotiationneeded as backup
                                setTimeout(() => {
                                    if (pc.signalingState === 'stable') {
                                        pc.dispatchEvent(new Event('negotiationneeded'));
                                    }
                                }, 100);
                                
                                console.log(`ðŸŽ¥ âœ… SENT RENEGOTIATION OFFER to ${userId.substring(0,8)}`);
                            } else {
                                console.log(`ðŸŽ¥ âš ï¸ Cannot renegotiate now, state: ${pc.signalingState}`);
                            }
                        }
                    } catch (e) {
                        console.error(`ðŸŽ¥ âŒ Error with ${userId.substring(0,8)}:`, e);
                    }
                }
                
                // RETRY MECHANISM - Try again if needed
                if (attempts < maxAttempts) {
                    setTimeout(() => {
                        console.log(`ðŸŽ¥ ðŸ”„ Retrying in 2 seconds... (attempt ${attempts + 1}/${maxAttempts})`);
                        sendParticipantVideo();
                    }, 2000);
                }
            };
            
            // Start the process after a delay to ensure everything is ready
            setTimeout(sendParticipantVideo, 1000);
        }

        // Make functions globally available for onclick handlers
        window.leaveSlot = leaveSlot;

        // Welcome message after socket connection
        function showWelcomeMessage() {
            if (isHost) {
                setTimeout(() => {
                    addChatMessage('System', 'ðŸ» Welcome to your pub! Others can join by visiting the pub page and clicking on your pub table.', true);
                    setTimeout(() => {
                        addChatMessage('System', 'ðŸ’¡ Tip: Turn on your camera and start the stream to let people know you\'re here!', true);
                    }, 2000);
                }, 1000);
            } else {
                setTimeout(() => {
                    addChatMessage('System', `ðŸ» Welcome ${currentUser}! You've joined the pub table.`, true);
                    setTimeout(() => {
                        addChatMessage('System', 'ðŸ’¡ Tip: Turn on your camera and mic to join the conversation!', true);
                    }, 2000);
                }, 1000);
            }
        }
        
        // Periodic connection health check
        function startConnectionHealthCheck() {
            setInterval(() => {
                // Check for stuck connections and slots showing "Connecting"
                document.querySelectorAll('.connecting-indicator').forEach(indicator => {
                    const slot = indicator.closest('[id^="participant"]');
                    if (slot) {
                        const userId = slot.getAttribute('data-occupied-by');
                        if (userId) {
                            const pc = peerConnections.get(userId);
                            const remoteStream = remoteStreams.get(userId);
                            
                            // If we have a remote stream but still showing connecting, fix it
                            if (remoteStream && remoteStream.getVideoTracks().length > 0) {
                                console.log(`ðŸ”§ Health check: Found stuck slot for ${userId}, fixing...`);
                                const video = slot.querySelector('video');
                                if (video) {
                                    video.srcObject = remoteStream;
                                    video.style.display = 'block';
                                    indicator.remove();
                                }
                            }
                            // If connection is failed, try to restart it
                            else if (pc && (pc.connectionState === 'failed' || pc.iceConnectionState === 'failed')) {
                                console.log(`ðŸ”§ Health check: Restarting failed connection for ${userId}`);
                                pc.close();
                                peerConnections.delete(userId);
                                remoteStreams.delete(userId);
                                createPeerConnection(userId);
                                setTimeout(() => updatePeerConnections(), 100);
                            }
                        }
                    }
                });
                
                // Check for stuck connections
                peerConnections.forEach((pc, userId) => {
                    const userSlot = document.querySelector(`[data-occupied-by="${userId}"]`);
                    const connectingIndicator = userSlot?.querySelector('.connecting-indicator');
                    
                    // If we see a connecting indicator for more than 10 seconds, try to recover
                    if (connectingIndicator) {
                        const connectionAge = Date.now() - (pc.connectionStartTime || Date.now());
                        if (connectionAge > 10000) { // 10 seconds
                            console.log(`Connection to ${userId} stuck for ${connectionAge}ms, attempting recovery...`);
                            
                            // Try to restart the connection
                            pc.close();
                            peerConnections.delete(userId);
                            remoteStreams.delete(userId);
                            
                            // Recreate connection
                            setTimeout(() => {
                                createPeerConnection(userId);
                                updatePeerConnections();
                            }, 1000);
                        }
                    }
                });
            }, 5000); // Check every 5 seconds
        }

        // WebRTC functions
        function createPeerConnection(userId) {
            console.log('ðŸ”§ Creating peer connection to:', userId.substring(0,8));
            
            const peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10
            });
            
            // SIMPLE FIX: No complex transceiver setup - let WebRTC handle it automatically
            
            let isNegotiating = false;
            peerConnection.onnegotiationneeded = async () => {
                if (isNegotiating) {
                    console.log(`Skipping negotiation for ${userId}, already in progress.`);
                    return;
                }
                
                // Check if we have any tracks to negotiate
                const senders = peerConnection.getSenders();
                const hasActiveTracks = senders.some(sender => sender.track && sender.track.readyState === 'live');
                
                if (!hasActiveTracks) {
                    console.log(`Skipping negotiation for ${userId}, no active tracks to send`);
                    return;
                }
                
                try {
                    isNegotiating = true;
                    console.log(`Negotiation needed for ${userId}, creating offer...`);
                    console.log(`Tracks to send: ${senders.filter(s => s.track).map(s => s.track.kind).join(', ')}`);
                    
                    // Only proceed if connection is stable
                    if (peerConnection.signalingState === 'stable') {
                        const offer = await peerConnection.createOffer();
                        await peerConnection.setLocalDescription(offer);
                        socket.emit('offer', {
                            target: userId,
                            offer: peerConnection.localDescription
                        });
                        console.log(`Offer sent to ${userId} with ${senders.filter(s => s.track).length} tracks`);
                    } else {
                        console.log(`Skipping offer creation for ${userId}, signaling state: ${peerConnection.signalingState}`);
                    }
                } catch (err) {
                    console.error(`Failed to create offer for ${userId}:`, err);
                } finally {
                    isNegotiating = false;
                }
            };

            peerConnections.set(userId, peerConnection);
            peerConnection.connectionStartTime = Date.now();

            // DO NOT ADD TRACKS HERE. They will be added by updatePeerConnections.

            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log('ðŸŽ¬ ðŸ”¥ ONTRACK EVENT FIRED! Received remote stream from:', userId.substring(0,8));
                console.log('ðŸŽ¬ Event details:', {
                    streams: event.streams.length,
                    track: event.track.kind,
                    trackEnabled: event.track.enabled,
                    trackState: event.track.readyState
                });
                
                const [remoteStream] = event.streams;
                remoteStreams.set(userId, remoteStream);
                
                // Log track details for debugging
                remoteStream.getTracks().forEach((track, index) => {
                    console.log(`ðŸŽ¬ Track ${index} from ${userId.substring(0,8)}: ${track.kind}, enabled: ${track.enabled}, state: ${track.readyState}`);
                });
                
                console.log(`ðŸŽ¬ ðŸš€ FORCING DISPLAY of stream from ${userId.substring(0,8)}...`);
                
                // AGGRESSIVE DISPLAY ATTEMPTS - Force show the video
                const forceDisplayVideo = () => {
                    displayRemoteVideo(userId, remoteStream);
                    
                    // Also force update any stuck connecting indicators
                    const userSlot = document.querySelector(`[data-occupied-by="${userId}"]`);
                    if (userSlot) {
                        const connectingIndicator = userSlot.querySelector('.connecting-indicator');
                        if (connectingIndicator) {
                            console.log(`ðŸŽ¬ ðŸ’¥ FORCE REMOVING connecting indicator for ${userId.substring(0,8)}`);
                            const video = userSlot.querySelector('video');
                            if (video) {
                                video.srcObject = remoteStream;
                                video.style.display = 'block';
                                connectingIndicator.remove();
                                console.log(`ðŸŽ¬ âœ… SUCCESSFULLY DISPLAYED participant video!`);
                            }
                        }
                    }
                };
                
                // Multiple aggressive attempts
                forceDisplayVideo();
                setTimeout(forceDisplayVideo, 100);
                setTimeout(forceDisplayVideo, 500);
                setTimeout(forceDisplayVideo, 1000);
                setTimeout(forceDisplayVideo, 2000);
            };

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', {
                        target: userId,
                        candidate: event.candidate
                    });
                }
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log(`Peer connection to ${userId} state:`, peerConnection.connectionState);
                
                // If connection fails, try to re-establish after a delay
                if (peerConnection.connectionState === 'failed') {
                    console.log(`Connection to ${userId} failed, attempting to reconnect...`);
                    setTimeout(() => {
                        if (peerConnections.has(userId) && peerConnections.get(userId).connectionState === 'failed') {
                            console.log(`Recreating failed connection to ${userId}`);
                            peerConnections.get(userId).close();
                            createPeerConnection(userId);
                            setTimeout(() => {
                                updatePeerConnections();
                            }, 100);
                        }
                    }, 2000);
                }
            };
            
            // Handle ICE connection state changes
            peerConnection.oniceconnectionstatechange = () => {
                console.log(`ICE connection to ${userId} state:`, peerConnection.iceConnectionState);
                
                if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected') {
                    console.log(`ICE connection to ${userId} failed/disconnected, attempting recovery...`);
                    
                    // Try ICE restart for failed connections
                    if (peerConnection.iceConnectionState === 'failed') {
                        setTimeout(async () => {
                            if (peerConnections.has(userId) && peerConnection.signalingState === 'stable') {
                                console.log(`Attempting ICE restart for ${userId}`);
                                try {
                                    const offer = await peerConnection.createOffer({ iceRestart: true });
                                    await peerConnection.setLocalDescription(offer);
                                    socket.emit('offer', {
                                        target: userId,
                                        offer: offer
                                    });
                                } catch (error) {
                                    console.error(`ICE restart failed for ${userId}:`, error);
                                }
                            }
                        }, 1000);
                    }
                }
            };

            return peerConnection;
        }

        async function createOffer(userId, peerConnection) {
            try {
                console.log('Creating offer for:', userId);
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                socket.emit('offer', {
                    target: userId,
                    offer: offer
                });
            } catch (error) {
                console.error('Error creating offer:', error);
            }
        }

        async function handleOffer(data) {
            const { offer, sender } = data;
            console.log('ðŸ“¨ Received offer from:', sender.substring(0,8), 'offer type:', offer.type);
            console.log('ðŸ“¨ Offer SDP contains video:', offer.sdp.includes('m=video'));
            console.log('ðŸ“¨ Offer SDP contains audio:', offer.sdp.includes('m=audio'));
            
            // Check if this is a renegotiation offer (connection already exists)
            const existingConnection = peerConnections.has(sender);
            if (existingConnection) {
                console.log('ðŸŽ¥ ðŸ”¥ RENEGOTIATION OFFER RECEIVED - Participant sending video!');
                console.log('ðŸŽ¥ ðŸ“º This should fix the connecting camera issue!');
            }
            
            let peerConnection = peerConnections.get(sender);
            
            // If no peer connection exists, create one
            if (!peerConnection) {
                console.log(`ðŸ“¨ Creating new peer connection for incoming offer from ${sender.substring(0,8)}`);
                peerConnection = createPeerConnection(sender);
            }

            try {
                // COLLISION DETECTION: Check if we're also trying to create an offer
                if (peerConnection.signalingState === 'have-local-offer') {
                    console.log(`ðŸ“¨ COLLISION DETECTED with ${sender.substring(0,8)}! Both sides creating offers.`);
                    
                    // Resolve collision by comparing socket IDs (lexicographic order)
                    if (socket.id < sender) {
                        console.log(`ðŸ“¨ I win collision resolution, ignoring incoming offer from ${sender.substring(0,8)}`);
                        return; // Ignore their offer, continue with ours
                    } else {
                        console.log(`ðŸ“¨ They win collision resolution, restarting connection with ${sender.substring(0,8)}`);
                        // Close our connection and start fresh
                        peerConnection.close();
                        peerConnection = createPeerConnection(sender);
                    }
                }
                
                // Check if we can accept this offer
                if (peerConnection.signalingState !== 'stable' && peerConnection.signalingState !== 'have-remote-offer') {
                    console.log(`ðŸ“¨ Cannot handle offer from ${sender.substring(0,8)}, signaling state: ${peerConnection.signalingState}`);
                    // For renegotiation, wait a moment and try again
                    if (existingConnection) {
                        console.log(`ðŸ“¨ Waiting for stable state to handle renegotiation...`);
                        setTimeout(() => {
                            if (peerConnection.signalingState === 'stable') {
                                handleOffer(data);
                            }
                        }, 1000);
                    }
                    return;
                }

                console.log(`ðŸ“¨ Setting remote description for user ${sender.substring(0,8)}`);
                await peerConnection.setRemoteDescription(offer);
                
                // Process any queued ICE candidates
                if (peerConnection.queuedCandidates) {
                    console.log(`ðŸ“¨ Processing ${peerConnection.queuedCandidates.length} queued ICE candidates for ${sender.substring(0,8)}`);
                    for (const candidate of peerConnection.queuedCandidates) {
                        try {
                            await peerConnection.addIceCandidate(candidate);
                        } catch (e) {
                            console.error(`ðŸ“¨ Error adding queued ICE candidate:`, e);
                        }
                    }
                    peerConnection.queuedCandidates = [];
                }
                
                // SIMPLE FIX: Add our tracks if we have them and are in a slot
                const mySlot = document.querySelector(`[data-occupied-by="${socket.id}"]`);
                const shouldSendVideo = isHost ? isCameraOn : (mySlot && isCameraOn);
                
                if (localStream && shouldSendVideo) {
                    console.log(`Adding our tracks before creating answer for ${sender.substring(0,8)}`);
                    try {
                        // Add tracks directly - simpler approach
                        localStream.getTracks().forEach(track => {
                            const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === track.kind);
                            if (!sender) {
                                peerConnection.addTrack(track, localStream);
                                console.log(`Added ${track.kind} track to answer for ${sender.substring(0,8)}`);
                            }
                        });
                    } catch (trackError) {
                        console.error(`Error adding tracks before answer:`, trackError);
                    }
                }
                
                console.log(`ðŸ“¨ Creating answer for user ${sender.substring(0,8)}`);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                console.log(`ðŸ“¨ Sending answer to user ${sender.substring(0,8)}`);
                socket.emit('answer', {
                    target: sender,
                    answer: answer
                });
                
                console.log(`ðŸ“¨ Successfully handled offer from user ${sender.substring(0,8)}`);
            } catch (error) {
                console.error('ðŸ“¨ Error handling offer from', sender.substring(0,8), ':', error);
                
                // If there's an error, try to restart the connection
                console.log(`ðŸ“¨ Restarting connection with ${sender.substring(0,8)} due to error`);
                peerConnection.close();
                peerConnections.delete(sender);
                setTimeout(() => {
                    createPeerConnection(sender);
                }, 1000);
            }
        }

        async function handleAnswer(data) {
            const { answer, sender } = data;
            console.log('ðŸ“¬ Received answer from:', sender.substring(0,8), 'answer type:', answer.type);
            
            const peerConnection = peerConnections.get(sender);

            if (peerConnection) {
                try {
                    // Check if we're in the correct state to accept an answer
                    if (peerConnection.signalingState !== 'have-local-offer') {
                        console.log(`ðŸ“¬ Cannot accept answer from ${sender.substring(0,8)}, wrong state: ${peerConnection.signalingState}`);
                        return;
                    }
                    
                    console.log(`ðŸ“¬ Setting remote description (answer) for user ${sender.substring(0,8)}`);
                    await peerConnection.setRemoteDescription(answer);
                    
                    // Process any queued ICE candidates
                    if (peerConnection.queuedCandidates) {
                        console.log(`ðŸ“¬ Processing ${peerConnection.queuedCandidates.length} queued ICE candidates for ${sender.substring(0,8)}`);
                        for (const candidate of peerConnection.queuedCandidates) {
                            try {
                                await peerConnection.addIceCandidate(candidate);
                            } catch (e) {
                                console.error(`ðŸ“¬ Error adding queued ICE candidate:`, e);
                            }
                        }
                        peerConnection.queuedCandidates = [];
                    }
                    
                    console.log(`ðŸ“¬ Successfully set remote description for user ${sender.substring(0,8)}`);
                } catch (error) {
                    console.error('ðŸ“¬ Error handling answer from', sender.substring(0,8), ':', error);
                    
                    // If there's an error, restart the connection
                    console.log(`ðŸ“¬ Restarting connection with ${sender.substring(0,8)} due to answer error`);
                    peerConnection.close();
                    peerConnections.delete(sender);
                    setTimeout(() => {
                        createPeerConnection(sender);
                        updatePeerConnections();
                    }, 1000);
                }
            } else {
                console.error('ðŸ“¬ No peer connection found for user', sender.substring(0,8));
            }
        }

        async function handleIceCandidate(data) {
            const { candidate, sender } = data;
            const peerConnection = peerConnections.get(sender);

            if (peerConnection) {
                try {
                    // Only add ICE candidates if we have remote description set
                    if (peerConnection.remoteDescription) {
                        console.log(`ðŸ§Š Adding ICE candidate from ${sender.substring(0,8)}`);
                        await peerConnection.addIceCandidate(candidate);
                    } else {
                        console.log(`ðŸ§Š Queuing ICE candidate from ${sender.substring(0,8)} (no remote description yet)`);
                        // Store candidate for later
                        if (!peerConnection.queuedCandidates) {
                            peerConnection.queuedCandidates = [];
                        }
                        peerConnection.queuedCandidates.push(candidate);
                    }
                } catch (error) {
                    console.error(`ðŸ§Š Error adding ICE candidate from ${sender.substring(0,8)}:`, error);
                }
            } else {
                console.error(`ðŸ§Š No peer connection found for ICE candidate from ${sender.substring(0,8)}`);
            }
        }

        function displayRemoteVideo(userId, stream) {
            console.log(`Displaying remote video from: ${userId}. My ID: ${socket.id}. Streamer ID: ${streamerId}. Is Host: ${isHost}`);

            // Validate stream has video tracks
            const videoTracks = stream.getVideoTracks();
            if (videoTracks.length === 0) {
                console.log(`No video tracks in stream from ${userId}`);
                return;
            }
            
            console.log(`Stream from ${userId} has ${videoTracks.length} video track(s), enabled: ${videoTracks[0].enabled}`);

            // If I am a participant, and this stream is from the broadcaster, show it in the main video.
            if (!isHost && userId === streamerId) {
                console.log(`I am a participant, and this is the host's stream. Displaying in main video.`);
                const hostVideo = document.getElementById('hostVideo');
                const videoPlaceholder = document.getElementById('videoPlaceholder');
                
                if (hostVideo && videoPlaceholder) {
                    console.log('Setting host video source...');
                    hostVideo.srcObject = stream;
                    hostVideo.style.display = 'block';
                    videoPlaceholder.style.display = 'none';
                    
                    // Ensure video plays
                    hostVideo.play().then(() => {
                        console.log('Host video started playing successfully');
                        addChatMessage('System', 'ðŸ“º Broadcaster camera is now visible!', true);
                    }).catch(e => {
                        console.error("Host video play failed:", e);
                        // Retry play after a short delay
                        setTimeout(() => {
                            hostVideo.play().catch(e2 => console.error("Host video retry failed:", e2));
                        }, 500);
                    });
                }
                return; // Stop here, don't try to put the host in a participant slot.
            }

            // For all other cases (I am host, or this is another participant's stream), handle slot display.
            const userSlot = document.querySelector(`[data-occupied-by="${userId}"]`);
            if (userSlot) {
                console.log(`Found slot for user ${userId}, updating video.`);
                const video = userSlot.querySelector('video');
                const connectingIndicator = userSlot.querySelector('.connecting-indicator');

                if (video) {
                    console.log(`Setting participant video source for ${userId}...`);
                    video.srcObject = stream;
                    video.style.display = 'block';
                    if (connectingIndicator) {
                        connectingIndicator.remove();
                    }
                    
                    // Ensure video plays
                    video.play().then(() => {
                        console.log(`Participant video for ${userId} started playing successfully`);
                        addChatMessage('System', `ðŸ“¹ ${userId.substring(0,4)}'s camera connected!`, true);
                    }).catch(e => {
                        console.error(`Participant video play failed for ${userId}:`, e);
                        // Retry play after a short delay
                        setTimeout(() => {
                            video.play().catch(e2 => console.error(`Participant video retry failed for ${userId}:`, e2));
                        }, 500);
                    });
                }
            } else {
                console.log(`No slot found for user ${userId}, storing stream for later.`);
                remoteStreams.set(userId, stream);
            }
        }

        function addParticipantVideo(userId, stream, targetSlotNumber = null) {
            let targetSlot = null;
            
            if (targetSlotNumber) {
                // Use specific slot if requested
                targetSlot = document.getElementById(`participant${targetSlotNumber}`);
            } else {
                // Find first empty slot
                for (let i = 1; i <= 6; i++) {
                    const slot = document.getElementById(`participant${i}`);
                    if (slot && slot.querySelector('.participant-placeholder')) {
                        targetSlot = slot;
                        break;
                    }
                }
            }
            
            if (targetSlot) {
                const slotNumber = targetSlot.id.replace('participant', '');
                targetSlot.innerHTML = `
                    <video autoplay muted playsinline class="participant-video"></video>
                    <div class="participant-name">Patron ${slotNumber}</div>
                `;
                const video = targetSlot.querySelector('video');
                video.srcObject = stream;
                video.setAttribute('data-user-id', userId);
                
                // Store which slot this user is in
                targetSlot.setAttribute('data-occupied-by', userId);
            }
        }

        function setupParticipantSlotHandlers() {
            // Add click handlers to participant slots for guests
            if (!isHost) {
                for (let i = 1; i <= 6; i++) {
                    const slot = document.getElementById(`participant${i}`);
                    if (slot) {
                        slot.addEventListener('click', () => handleSlotClick(i));
                        slot.style.cursor = 'pointer';
                        slot.classList.add('clickable-slot');
                        
                        // Add hover effect for empty slots
                        slot.addEventListener('mouseenter', () => {
                            if (slot.querySelector('.participant-placeholder')) {
                                slot.querySelector('.participant-placeholder').innerHTML = `
                                    <i class="fas fa-video"></i>
                                    <span>Click to join with camera</span>
                                `;
                            }
                        });
                        
                        slot.addEventListener('mouseleave', () => {
                            if (slot.querySelector('.participant-placeholder')) {
                                slot.querySelector('.participant-placeholder').innerHTML = `
                                    <i class="fas fa-user-plus"></i>
                                    <span>Empty Slot</span>
                                `;
                            }
                        });
                    }
                }
                
                // Add instruction message for participants
                setTimeout(() => {
                    addChatMessage('System', 'ðŸ’¡ Tip: Click on any empty slot to join with your camera!', true);
                }, 3000);
            }
        }

        async function handleSlotClick(slotNumber) {
            const slot = document.getElementById(`participant${slotNumber}`);
            
            // Check if slot is empty and user isn't already in a slot
            if (!slot.querySelector('.participant-placeholder')) {
                addChatMessage('System', 'This slot is already occupied!', true);
                return;
            }
            
            // Check if user is already in another slot
            const existingSlot = document.querySelector(`[data-occupied-by="${socket.id}"]`);
            if (existingSlot) {
                addChatMessage('System', 'You are already in a camera slot! Leave your current slot first.', true);
                return;
            }
            
            try {
                // Request camera access if not already available
                if (!localStream || !isCameraOn) {
                    await requestCameraAccess();
                }
                
                // Wait a moment to ensure stream is fully ready
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Show user's video in the selected slot (NOT in main window)
                slot.innerHTML = `
                    <video autoplay muted playsinline class="participant-video"></video>
                    <div class="participant-name">You (Patron ${slotNumber})</div>
                    <button class="leave-slot-btn" onclick="leaveSlot(${slotNumber})">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                
                const video = slot.querySelector('video');
                video.srcObject = localStream;
                slot.setAttribute('data-occupied-by', socket.id);
                
                // Enable camera if not already on
                if (!isCameraOn) {
                    // Turn on camera but ensure main window still shows broadcaster
                    isCameraOn = true;
                    const cameraBtn = document.getElementById('cameraBtn');
                    const cameraIcon = cameraBtn.querySelector('i');
                    cameraBtn.classList.add('active');
                    cameraIcon.className = 'fas fa-video';
                    
                    // Enable video track
                    if (localStream) {
                        localStream.getVideoTracks().forEach(track => {
                            track.enabled = true;
                            console.log(`ðŸŽ¥ Enabled video track for slot join: ${track.label}, enabled: ${track.enabled}`);
                        });
                    }
                }
                
                // Also enable microphone for better communication
                if (!isMicOn) {
                    isMicOn = true;
                    const micBtn = document.getElementById('micBtn');
                    const micIcon = micBtn.querySelector('i');
                    micBtn.classList.add('active');
                    micIcon.className = 'fas fa-microphone';
                    
                    if (localStream) {
                        localStream.getAudioTracks().forEach(track => {
                            track.enabled = true;
                            console.log(`ðŸŽ¥ Enabled audio track for slot join: ${track.label}, enabled: ${track.enabled}`);
                        });
                    }
                }

                // Notify server and other users that this user joined a slot FIRST
                socket.emit('join-slot', { slotNumber });

                // Log connection states periodically for debugging
                setTimeout(() => {
                    console.log('ðŸŽ¥ Participant joined slot, checking connection states...');
                    for (const [userId, pc] of peerConnections.entries()) {
                        console.log(`ðŸŽ¥ Connection ${userId.substring(0,8)}: ${pc.connectionState}/${pc.signalingState}/${pc.iceConnectionState}`);
                    }
                }, 2000);
                
                addChatMessage('System', `You joined the conversation in slot ${slotNumber}! ðŸ“¹`, true);
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                addChatMessage('System', 'Could not access camera. Please allow camera permissions and try again.', true);
            }
        }

        async function requestCameraAccess() {
            if (!localStream) {
                // Initialize camera access
                await initializePubStream();
            }
        }

        function leaveSlot(slotNumber) {
            const slot = document.getElementById(`participant${slotNumber}`);
            if (slot && slot.getAttribute('data-occupied-by') === socket.id) {
                // Reset slot to empty state
                slot.innerHTML = `
                    <div class="participant-placeholder">
                        <i class="fas fa-user-plus"></i>
                        <span>Empty Slot</span>
                    </div>
                `;
                slot.removeAttribute('data-occupied-by');
                
                // Notify server and other users that this user left a slot
                socket.emit('leave-slot', { slotNumber });
                
                // Turn off camera
                if (isCameraOn) {
                    toggleCamera();
                }
                
                addChatMessage('System', `You left camera slot ${slotNumber}.`, true);
            }
        }

        // Add debug button for easier access
        window.debugParticipantConnections = function() {
            console.log('=== PARTICIPANT CONNECTION DEBUG ===');
            console.log(`Current user ID: ${socket.id}`);
            console.log(`Is Host: ${isHost}`);
            console.log(`Streamer ID: ${streamerId}`);
            
            // Check participant slots
            for (let i = 1; i <= 6; i++) {
                const slot = document.getElementById(`participant${i}`);
                const occupiedBy = slot?.getAttribute('data-occupied-by');
                const hasConnecting = slot?.querySelector('.connecting-indicator');
                
                if (occupiedBy) {
                    console.log(`Slot ${i}: Occupied by ${occupiedBy.substring(0,8)}, Connecting: ${!!hasConnecting}`);
                    
                    const pc = peerConnections.get(occupiedBy);
                    const remoteStream = remoteStreams.get(occupiedBy);
                    
                    if (pc) {
                        console.log(`  Peer Connection: ${pc.connectionState}/${pc.signalingState}/${pc.iceConnectionState}`);
                        console.log(`  Remote Stream: ${remoteStream ? 'Available' : 'Missing'}`);
                        
                        if (remoteStream) {
                            console.log(`  Remote Video Tracks: ${remoteStream.getVideoTracks().length}`);
                            remoteStream.getVideoTracks().forEach((track, idx) => {
                                console.log(`    Track ${idx}: enabled=${track.enabled}, state=${track.readyState}`);
                            });
                        }
                    } else {
                        console.log(`  No peer connection found!`);
                    }
                }
            }
            console.log('=== END DEBUG ===');
        };
    </script>
</body>
</html> 
</html> 